
import Stomp from 'stompjs';
import CJ from 'circular-json';

import CTE from './patterns/cte';
import RPC from './patterns/rpc';
import Topic from './patterns/topic';

import React from 'react';

/**
 * Redux Enabled Rabbit Client ( websockets stomp to webstomp )
 *
**/
export default class ReduxRabbit {

	constructor( props ) {

		props = props || {};
		this.setInitialState();
	}

	setInitialState() {

		this.configured = false;
		this.connected = false;
		this.patterns = {};
	}

	/**
	*
	* Configure ReduxRabbit
	*
	* @param props {object}
	* @param props.config {object}
	* @param props.config.endpoint {string} the endpoint uri ( eg ws://someone:secret@rabbithost:port )
	*
	**/
	configure( props ) {

		props = props || {};
		if( props.config )	this.config = props.config;
		if( props.dispatch ) this.dispatch = props.dispatch;
		if( props.connect ) this.connect();
		this.configured = true;
	}

	/**
	* Connect to the RabbitMQ Server.
	* @param config {object} @see this.configure - when argued, rabbit acquires the configuration provided
	**/
	connect( config ) {

		return new Promise( ( resolve, reject ) => {

			if( config ) this.configure( config );

			var ws, { user, pass, endpoint } = this.parseEndpoint( this.config.endpoint );

			console.log( '....', this.config)
			console.log( 'using endpoint', endpoint );
			ws = new WebSocket( endpoint );

			this.stomp = Stomp.over( ws );
			this.stomp.heartbeat.outgoing = 20000;

			// rabbit webstomp does not support heartbeats.
			this.stomp.heartbeat.incoming = 0;

			this.stomp.connect( user, pass, () => {

				this.bindPatterns();
				Object.keys( this.patterns ).forEach( ( qpattern ) => {

					this.patterns[ qpattern ].attachClient( this.stomp );
				});

				this.connected = true;
				if( this.dispatch )
					this.dispatch({ type: 'redux_rabbit_connected', payload: { connected: true } });
				resolve( true );

			},
			( err ) => {
				reject( err.body );
			});

		})
	}

	bindPatterns() {

		this.patterns = {
			cte: new CTE(),
			rpc: new RPC(),
			topic: new Topic()
		};
	}

	isValidConfig() {

		if( this.config ) return true;
	}

	parseEndpoint( endpoint ) {

		var ret, credentials, strippedEndpoint;

		if( endpoint.indexOf( 'ws://' ) === -1 )
			endpoint = 'ws://' + endpoint;

		//no 'at' symbol means no credentials.
		if( endpoint.indexOf( '@' ) === -1 ){

			return {
				user: null,
				pass: null,
				endpoint: endpoint
			};
		}

		try {

			credentials = endpoint.split( '@' )[ 0 ].split( '/' )[ 2 ].split( ':' );
			strippedEndpoint = endpoint.split( '@' )[ 1 ];

		} catch( e ) {

			throw( 'User credentials supplied but are unusable on endpoint ' + endpoint );
		}

		return {
			user: credentials[ 0 ],
			pass: credentials[ 1 ],
			endpoint: 'ws://' +  strippedEndpoint
		}

	}
}

export const ReduxRabbitInstance = new ReduxRabbit();

export const withReduxRabbit = function( args ) {

	args = args || {};

	return function( target ) {

		var configure;

		//if our decorator is argued a config and isn't instanced.
		configure = !!( args.config && !ReduxRabbitInstance.configured );

		//if this is a react component
		if( target.prototype.isReactComponent ){

			return function( props, name, descriptor ) {

				props = props || {};

				//if we're instantiating the class ( ie. ReduxRabbitInstance is null/not an instance, and we've been argued a config into the decorator )
				if( configure && !ReduxRabbitInstance.configured ) {

					if( props.dispatch ) args = Object.assign( { dispatch: props.dispatch }, args );
					ReduxRabbitInstance.configure( args )

					//warn that without a dispatcher, we won't be dispatching anything to the redux store.
					if( !props.dispatch ) {
						console.warn( 'RabbitRedux has instantiated but in order to dispatch actions, requires the redux store dispatcher be present, did you decorate with redux connect, and after it?' );
					}

				}

				var newProps = Object.assign( {}, props );
				newProps.mq = ReduxRabbitInstance;
				return React.createElement( target, newProps );
			}

		}
		else {

			target.prototype.mq = ReduxRabbitInstance;
		}

	}

}
