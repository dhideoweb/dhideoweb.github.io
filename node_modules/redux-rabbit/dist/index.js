'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.withReduxRabbit = exports.ReduxRabbitInstance = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _stompjs = require('stompjs');

var _stompjs2 = _interopRequireDefault(_stompjs);

var _circularJson = require('circular-json');

var _circularJson2 = _interopRequireDefault(_circularJson);

var _cte = require('./patterns/cte');

var _cte2 = _interopRequireDefault(_cte);

var _rpc = require('./patterns/rpc');

var _rpc2 = _interopRequireDefault(_rpc);

var _topic = require('./patterns/topic');

var _topic2 = _interopRequireDefault(_topic);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Redux Enabled Rabbit Client ( websockets stomp to webstomp )
 *
**/
var ReduxRabbit = function () {
	function ReduxRabbit(props) {
		_classCallCheck(this, ReduxRabbit);

		props = props || {};
		this.setInitialState();
	}

	_createClass(ReduxRabbit, [{
		key: 'setInitialState',
		value: function setInitialState() {

			this.configured = false;
			this.connected = false;
			this.patterns = {};
		}

		/**
  *
  * Configure ReduxRabbit
  *
  * @param props {object}
  * @param props.config {object}
  * @param props.config.endpoint {string} the endpoint uri ( eg ws://someone:secret@rabbithost:port )
  *
  **/

	}, {
		key: 'configure',
		value: function configure(props) {

			props = props || {};
			if (props.config) this.config = props.config;
			if (props.dispatch) this.dispatch = props.dispatch;
			if (props.connect) this.connect();
			this.configured = true;
		}

		/**
  * Connect to the RabbitMQ Server.
  * @param config {object} @see this.configure - when argued, rabbit acquires the configuration provided
  **/

	}, {
		key: 'connect',
		value: function connect(config) {
			var _this = this;

			return new Promise(function (resolve, reject) {

				if (config) _this.configure(config);

				var ws,
				    _parseEndpoint = _this.parseEndpoint(_this.config.endpoint),
				    user = _parseEndpoint.user,
				    pass = _parseEndpoint.pass,
				    endpoint = _parseEndpoint.endpoint;

				console.log('....', _this.config);
				console.log('using endpoint', endpoint);
				ws = new WebSocket(endpoint);

				_this.stomp = _stompjs2.default.over(ws);
				_this.stomp.heartbeat.outgoing = 20000;

				// rabbit webstomp does not support heartbeats.
				_this.stomp.heartbeat.incoming = 0;

				_this.stomp.connect(user, pass, function () {

					_this.bindPatterns();
					Object.keys(_this.patterns).forEach(function (qpattern) {

						_this.patterns[qpattern].attachClient(_this.stomp);
					});

					_this.connected = true;
					if (_this.dispatch) _this.dispatch({ type: 'redux_rabbit_connected', payload: { connected: true } });
					resolve(true);
				}, function (err) {
					reject(err.body);
				});
			});
		}
	}, {
		key: 'bindPatterns',
		value: function bindPatterns() {

			this.patterns = {
				cte: new _cte2.default(),
				rpc: new _rpc2.default(),
				topic: new _topic2.default()
			};
		}
	}, {
		key: 'isValidConfig',
		value: function isValidConfig() {

			if (this.config) return true;
		}
	}, {
		key: 'parseEndpoint',
		value: function parseEndpoint(endpoint) {

			var ret, credentials, strippedEndpoint;

			if (endpoint.indexOf('ws://') === -1) endpoint = 'ws://' + endpoint;

			//no 'at' symbol means no credentials.
			if (endpoint.indexOf('@') === -1) {

				return {
					user: null,
					pass: null,
					endpoint: endpoint
				};
			}

			try {

				credentials = endpoint.split('@')[0].split('/')[2].split(':');
				strippedEndpoint = endpoint.split('@')[1];
			} catch (e) {

				throw 'User credentials supplied but are unusable on endpoint ' + endpoint;
			}

			return {
				user: credentials[0],
				pass: credentials[1],
				endpoint: 'ws://' + strippedEndpoint
			};
		}
	}]);

	return ReduxRabbit;
}();

exports.default = ReduxRabbit;
var ReduxRabbitInstance = exports.ReduxRabbitInstance = new ReduxRabbit();

var withReduxRabbit = exports.withReduxRabbit = function withReduxRabbit(args) {

	args = args || {};

	return function (target) {

		var configure;

		//if our decorator is argued a config and isn't instanced.
		configure = !!(args.config && !ReduxRabbitInstance.configured);

		//if this is a react component
		if (target.prototype.isReactComponent) {

			return function (props, name, descriptor) {

				props = props || {};

				//if we're instantiating the class ( ie. ReduxRabbitInstance is null/not an instance, and we've been argued a config into the decorator )
				if (configure && !ReduxRabbitInstance.configured) {

					if (props.dispatch) args = Object.assign({ dispatch: props.dispatch }, args);
					ReduxRabbitInstance.configure(args);

					//warn that without a dispatcher, we won't be dispatching anything to the redux store.
					if (!props.dispatch) {
						console.warn('RabbitRedux has instantiated but in order to dispatch actions, requires the redux store dispatcher be present, did you decorate with redux connect, and after it?');
					}
				}

				var newProps = Object.assign({}, props);
				newProps.mq = ReduxRabbitInstance;
				return _react2.default.createElement(target, newProps);
			};
		} else {

			target.prototype.mq = ReduxRabbitInstance;
		}
	};
};